#include <iostream>
#include <Windows.h>
//#include "gfx.h"
using namespace std;

#define LUNG_NAVE(_idNave) (_idNave + 1)
#define CHAR_TO_INT(_character) (toupper(_character) - 'A')

/*  Definizioni di costanti
*/
const int DIM_X = 10;
const int DIM_Y = 10;
const int NUMERO_CASELLE = DIM_X * DIM_Y;

//  Rateo max di caselle di navi che ci possono essere in relazione con il numero di caselle.
const float RATEO_CAPACITA_MAX = 0.30;

//  Costanti di definizione dei tipi di caselle.
const int ID_ACQUA = 0;
const int ID_NAVE = 1;
const int ID_ACQUA_COLPITA = 2;
const int ID_NAVE_COLPITA = 3;
const int ID_NAVE_AFFONDATA = 4;

//  Costanti per la definzione dell'id delle navi. Poco o niente utilizzate...
const int NUM_NAVI = 5;
const int ID_MINA = 0;
const int ID_CACCIATOR = 1;
const int ID_INCROCIATORE = 2;
const int ID_CORAZZATA = 3;
const int ID_PORTAERERI = 4;

//  Costanti per i caratteri da rappresentare.
//  Utilizziamo la code page 850 (default per applicazioni testuali, anche chiamata DOS-Latin1). 
//  Riferimento caratteri: https://en.wikipedia.org/wiki/Code_page_850
const char CHAR_ACQUA = 0xB0;
const char CHAR_NAVE = 0xCE;
const char CHAR_ACQUA_COLPITA = 0xFE;
const char CHAR_NAVE_COLPITA = 0xC5;
const char CHAR_NAVE_AFFONDATA = 0xB2;

//  Costanti per aiutarci con l'identificazione del verso (che viene spesso impresso sotto forma di valore booleano)
const int VERSO_ORIZZONTALE = true;
const int VERSO_VERTICALE = false;

//  Costanti per il nome delle navi. Ogni elemento ha l'indice che corrisponde all'ID delle navi. (es. VECT_NOMI_NAVI[ID_MINA] => "Mina")
const string VECT_NOMI_NAVI[NUM_NAVI] = {
    "Mina",                     // 0
    "Cacciator Pediniere",      // 1
    "Incrociatore",             // 2
    "Corazzata",                // 3
    "Portaerei"                 // 4
};

//  Dichiarazioni prototipi funzioni
void LeggiNumeriNavi(int[]);
bool ControllaSeMaxRateo(int);
void ChiediPosizioneNave(int&, int&);
bool ChiediVerso();
void InserimentoNavi(int[][DIM_Y], int[], HANDLE);
bool ControllaPosizionamento(int[][DIM_Y], int, int, bool, int);
void PosizionaNave(int[][DIM_Y], int, int, bool, int);
void DisegnaCampo(int[][DIM_Y], HANDLE);
void DisegnaBersagli(int[][DIM_Y], HANDLE);
void ResetMatrice(int[][DIM_Y], int);

void NaveOrizzontale(int[][DIM_Y], int, int);
void NaveVerticale(int[][DIM_Y], int, int);
bool NaviColpite(int[][DIM_Y], int, int);

void ChiediCoordinate(int&, int&);
int Gioco(int[][DIM_Y], int[][DIM_Y], HANDLE);

int main()
{
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);

    //  Dichiarazione matrici
    int matGiocatore1[DIM_X][DIM_Y];
    int matGiocatore2[DIM_X][DIM_Y];

    //  Reset matrici 
    ResetMatrice(matGiocatore1, ID_ACQUA);
    ResetMatrice(matGiocatore2, ID_ACQUA);

    //  Vettore nel quale vengono salvati il numero di navi per ogni tipo
    int vectNavi[NUM_NAVI];

    //  Richiesta e lettura numero navi per ogni tipo
    LeggiNumeriNavi(vectNavi);

    //  Inserimento navi per ogni giocatore
    InserimentoNavi(matGiocatore1, vectNavi, hConsole);
    InserimentoNavi(matGiocatore2, vectNavi, hConsole);

    //  gioco
    Gioco(matGiocatore1, matGiocatore2, hConsole);
}

/*  Procedura LeggiNumeriNavi
*
*   Chiede all'utente il numero di navi per ogni tipo e salva in vectNavi[].
*   Se le navi posizionate sono 0, allora prenderà i numeri da una tabella di default.
*   Se il numero complessivo di caselle occupate dalle navi fratto il numero di caselle
*   e' maggiore di RATEO_CAPACITA_MAX, allora il programma non permette di immettere più
*   navi.
*   Vedi come funziona vectNavi nelle ipotesi.
*/
void LeggiNumeriNavi(int vectNavi[])
{
    //  Calcolo caselle utilizzate.
    int numCaselleUtilizzate = 0;

    for (int i = 0; i < NUM_NAVI; i++)
    {
        int temp;
        bool ok;
        do
        {
            ok = true;
            //  Utilizziamo temp per non modificare il contenuto di numCaselleUtilizzate se l'utente inserisce qualcosa di non valido
            temp = numCaselleUtilizzate;

            //  Richiesta all'utente
            cout << "Quante navi di tipo " << VECT_NOMI_NAVI[i] << " (lunghezza: " << LUNG_NAVE(i) << ") vuoi? ";
            cin >> vectNavi[i];

            temp += vectNavi[i] * LUNG_NAVE(i);

            if (ControllaSeMaxRateo(temp))  //  Se il rateo massimo è sorpassato, allora non permettiamo all'utente di inserire la nave
            {
                cout << "Numero max di caselle per le navi raggiunto!!!" << endl;
                ok = false;
            }
            else if (vectNavi[i] < 0)       //  Anche se il numero di navi è invalido non permettiamo all'utente di continuare
            {
                cout << "Numero non valido!!!" << endl;
                ok = false;
            }
        } while (!ok);

        //  Aggiorniamo numCaselleUtilizzate
        numCaselleUtilizzate = temp;
    }

    if (numCaselleUtilizzate <= 0)  //  Se numCaselleUtilizzate è <= 0, allora carichiamo una configurazione di default
    {
        cout << "Nessuna nave in campo!!! Utilizzo Tabella di default!!!" << endl;
        vectNavi[ID_MINA] = 2;
        vectNavi[ID_CACCIATOR] = 3;
        vectNavi[ID_INCROCIATORE] = 3;
        vectNavi[ID_CORAZZATA] = 1;
        vectNavi[ID_PORTAERERI] = 0;
    }
}


/*  Funzione ControllaSeMaxRateo
*
*   Controlla se il RATEO_CAPACITA_MAX è stato sorpassato.
*/
bool ControllaSeMaxRateo(int numCaselleUtilizzate)
{
    if (((float)numCaselleUtilizzate / (float)NUMERO_CASELLE) > RATEO_CAPACITA_MAX)
        return true;
    return false;
}


/*  Funzione ChiediPosizioneNave
*
*   Chiede la posizione della nave, facendo in modo che l'input sia valido.
*/
void ChiediPosizioneNave(int& coordX, int& coordY)
{
    bool ok;

    do
    {
        ok = true;

        cout << "Inserisci la colonna sulla quale inserire la nave [1-10]: ";
        cin >> coordX;

        coordX--;   //  L'inizio della tabella per il computer è 0, mentre per un umano è 1.

        if (coordX < 0 || coordX >= DIM_X)  //  Controlliamo se la colonna è valida
        {
            cout << "colonna non valida!!!" << endl;
            ok = false;
        }
    } while (!ok);

    do
    {
        ok = true;
        char temp;

        cout << "Inserisci la riga sulla quale inserire la nave [A-J]: ";
        cin >> temp;
        temp = CHAR_TO_INT(temp);   //  Convertiamo il carattere in un numero mappato per 'A' = 0 e 'J' = 9

        //  Visto che char è praticamente un intero possiamo controllarlo come se fosse un int...
        if (temp < 0 || temp >= DIM_Y)
        {
            cout << "Input Non valido!!!" << endl;
            ok = false;
        }
        coordY = temp;
    } while (!ok);
}

/*  Funzione ChiediVerso
*
*   Chiede il verso della nave, facendo in modo che l'input sia valido.
*/
bool ChiediVerso()
{
    bool verso, ok;

    do
    {
        char temp;

        cout << "Vuoi inserire la nave [O]rizzontalmente o [V]erticalmente? [O/V] ";
        cin >> temp;

        temp = toupper(temp);

        if (temp != 'O' && temp != 'V') //  Controlliamo che la scelta sia valida
        {
            cout << "Input non valido!!!" << endl;
            ok = false;
        }
        else
        {
            verso = ((temp == 'O') ? VERSO_ORIZZONTALE : VERSO_VERTICALE);  //  Aggiorna verso
            ok = true;
        }
    } while (!ok);

    return verso;
}


/*  Procedura InserimentoNavi
*
*   Chiede all'utente per ogni nave la posizione ed il verso. Controlla se la posizione è valida (quindi non va fuori dal campo e
*   non tocca un'altra nave) e posiziona la nave.
*/
void InserimentoNavi(int matCampo[][DIM_Y], int vectNavi[], HANDLE hConsole)
{
    for (int i = (NUM_NAVI - 1); i >= 0; i--)
    {
        if (vectNavi[i] != 0)   // Immettiamo il messaggio solo se ci sono navi da inserire
            cout << "Inserisci le navi di tipo " << VECT_NOMI_NAVI[i] << " (lunghezza: " << LUNG_NAVE(i) << "):" << endl;

        for (int j = 0; j < vectNavi[i]; j++)
        {
            int coordX, coordY;
            bool verso = VERSO_ORIZZONTALE;
            bool ok;

            do
            {
                cout << "Nave numero " << j + 1 << ": " << endl;
                ChiediPosizioneNave(coordX, coordY);    //  Chiediamo la posizione della nave
                if (i != ID_MINA)   //  Se la nave non è una mina, chiediamo il verso
                    verso = ChiediVerso();
                if (!ControllaPosizionamento(matCampo, coordX, coordY, verso, i))   //  Controlliamo se la nave ci sta
                {
                    cout << "La nave non ci sta!!!" << endl;
                    ok = false;
                }
                else {
                    PosizionaNave(matCampo, coordX, coordY, verso, i);  //  Posizioniamo la nave e disegnamo il campo
                    ok = true;

                    system("cls");
                    DisegnaCampo(matCampo, hConsole);
                }
            } while (!ok);
        }
    }
}

/*  Funzione ControllaPosizionamento
*
*   Data la posizione della nave, il verso e la lunghezza, controlla tutte le caselle che circondano la nave.
*   Se una o più di queste caselle è una nave (ID_NAVE), allora la posizione è invalida e ritorniamo false.
*
*   NOTE:
*       - LungNave non è la lunghezza reale: sarebbe la lunghezza - 1
*       - Utilizziamo i return all'interno dei cicli per evitare di utilizzare condizioni extra. Utilizziamo sempre
*           cicli do-while, quindi indeterminati.
*       - Le coordinate in input non possono essere minori di 0 o maggiori della dimensione dellla matrice. Questo è
*           assicurato da ChiediPosizioneNave().
*/
bool ControllaPosizionamento(int matCampo[][DIM_Y], int coordX, int coordY, bool verso, int lungNave)
{
    if (verso == VERSO_ORIZZONTALE) //  Per ogni verso dobbiamo fare qualcosa di differente. La nave in questo caso è messa in orizzontale
    {
        if (coordX + lungNave >= DIM_X) //  Se la nave va fuori dalla matrice ritorniamo subito.
            return false;

        //  Calcolo delle coordinate iniziali all'esterno del ciclo per evitare di fare lo stesso calcolo più volte e per motivi di leggibilità.
        int startY = coordY - ((coordY <= 0) ? 0 : 1);  //  Se siamo nella prima riga della matrice non possiamo controllare più in alto
        int endY = coordY + ((coordY >= (DIM_Y - 1)) ? 0 : 1); //  Se siamo nella ultima riga della matrice non possiamo controllare più in basso
        int startX = coordX - ((coordX <= 0) ? 0 : 1); //  Se siamo nella prima colonna della matrice non possiamo controllare più a sinistra.
        int endX = coordX + lungNave + ((coordX >= (DIM_X - 1)) ? 0 : 1);   //  Se la nave arriva ad occupare l'ultima colonna della matrice non possiamo controllare più a destra

        //  Controlliamo ogni singola casella compresa tra (startX, startY) e tra (endX, endY) compresi.
        int y = startY;
        while (y <= endY)
        {
            int x = startX;
            while (x <= endX)
            {
                if (matCampo[x][y] == ID_NAVE)  //  Se troviamo una nave usciamo
                    return false;
                x++;
            }
            y++;
        }
    }
    else    //La nave  è messa in verticale
    {
        if (coordY + lungNave >= DIM_Y)  //  Se la nave va fuori dalla matrice ritorniamo subito.
            return false;

        //  Calcolo delle coordinate iniziali all'esterno del ciclo per evitare di fare lo stesso calcolo più volte e per motivi di leggibilità.
        int startY = coordY - ((coordY <= 0) ? 0 : 1);  //  Se siamo nella prima riga della matrice non possiamo controllare più in alto
        int endY = coordY + lungNave + ((coordY >= (DIM_Y - 1)) ? 0 : 1);   //  Se la nave arriva ad occupare l'ultima riga della matrice non possiamo controllare più in basso
        int startX = coordX - ((coordX <= 0) ? 0 : 1);  //  Se siamo nella prima colonna della matrice non possiamo controllare più a sinistra.
        int endX = coordX + ((coordX >= (DIM_X - 1)) ? 0 : 1);  //  Se siamo nell'ultima colonna della matrice non possiamo controllare più a destra.

        //  Controlliamo ogni singola casella compresa tra (startX, startY) e tra (endX, endY) compresi.
        int y = startY;
        while (y <= endY)
        {
            int x = startX;
            while (x <= endX)
            {
                if (matCampo[x][y] == ID_NAVE)  //  Se troviamo una nave usciamo
                    return false;
                x++;
            }
            y++;
        }
    }

    return true;
}


/*  Procedura PosizionaNave
*
*   Posiziona La nave nella matrice, senza fare controlli.
*/
void PosizionaNave(int matCampo[][DIM_Y], int coordX, int coordY, bool verso, int lungNave)
{
    if (verso == VERSO_ORIZZONTALE)
    {
        for (int x = coordX; x <= coordX + lungNave; x++)
            matCampo[x][coordY] = ID_NAVE;
    }
    else    //  Nave verticale
    {
        for (int y = coordY; y <= coordY + lungNave; y++)
            matCampo[coordX][y] = ID_NAVE;
    }
}


/*  Procedura DisegnaCampo
*
*   Disegna il proprio campo, segnalando le proprie navi, colpite e non colpite.
*   Dobbiamo solo disegnare la navi non colpite, le navi colpite e le navi affondate.
*/
void DisegnaCampo(int matCampo[][DIM_Y], HANDLE hConsole)
{
    //  Iteriamo per ogni elemento.
    for (int y = 0; y < DIM_Y; y++)
    {
        for (int x = 0; x < DIM_X; x++)
        {

            if (matCampo[x][y] == ID_ACQUA || matCampo[x][y] == ID_ACQUA_COLPITA)
            {
                SetConsoleTextAttribute(hConsole, FOREGROUND_BLUE | FOREGROUND_INTENSITY);
                cout << CHAR_ACQUA;
            }
            else if (matCampo[x][y] == ID_NAVE)
            {
                SetConsoleTextAttribute(hConsole, FOREGROUND_BLUE | FOREGROUND_RED | FOREGROUND_GREEN);
                cout << CHAR_NAVE;
            }
            else if (matCampo[x][y] == ID_NAVE_COLPITA)
            {
                SetConsoleTextAttribute(hConsole, FOREGROUND_RED | FOREGROUND_GREEN);
                cout << CHAR_NAVE_COLPITA;
            }
            else if (matCampo[x][y] == ID_NAVE_AFFONDATA)
            {
                SetConsoleTextAttribute(hConsole, FOREGROUND_RED | FOREGROUND_INTENSITY);
                cout << CHAR_NAVE_AFFONDATA;
            }
        }
        SetConsoleTextAttribute(hConsole, FOREGROUND_BLUE | FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY);
        cout << endl;
    }
}

/*  Procedura Disegna Campo.
*
*   Disegna dove abbiamo colpito nel campo dell'avversario.
*   Dobbiamo disegnare l'acqua colpita, le navi colpite e navi affondate.
*   Le navi non colpite vengono ignorate.
*/
void DisegnaBersagli(int matCampo[][DIM_Y], HANDLE hConsole)
{
    for (int y = 0; y < DIM_Y; y++)
    {
        for (int x = 0; x < DIM_X; x++)
        {
            if (matCampo[x][y] == ID_ACQUA_COLPITA)
            {
                SetConsoleTextAttribute(hConsole, BACKGROUND_BLUE | BACKGROUND_INTENSITY);
                cout << CHAR_ACQUA_COLPITA;
            }
            else if (matCampo[x][y] == ID_NAVE_COLPITA)
            {
                SetConsoleTextAttribute(hConsole, BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_INTENSITY);
                cout << CHAR_NAVE_COLPITA;
            }
            else if (matCampo[x][y] == ID_NAVE_AFFONDATA)
            {
                SetConsoleTextAttribute(hConsole, BACKGROUND_RED);
                cout << CHAR_NAVE_AFFONDATA;
            }
            else
            {
                SetConsoleTextAttribute(hConsole, FOREGROUND_BLUE | FOREGROUND_INTENSITY);
                cout << CHAR_ACQUA;
            }
        }
        SetConsoleTextAttribute(hConsole, FOREGROUND_BLUE | FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY);
        cout << endl;
    }
}


/*  Procedura ResetMatrice
*
*   Semplice funzione per resettare tutta una matrice ad un valore.
*/
void ResetMatrice(int matCampo[][DIM_Y], int valore)
{
    for (int y = 0; y < DIM_Y; y++)
        for (int x = 0; x < DIM_X; x++)
            matCampo[x][y] = valore;
}


/*  Procedura ChiediCoordinate
*
*   Richiede e controlla le coordinate sulle quali si vuole colpire.
*/
void ChiediCoordinate(int& coordX, int& coordY)
{
    bool ok;

    do
    {
        ok = true;

        cout << "Inserisci la colonna sulla quale vuoi colpire [1-10]: ";
        cin >> coordX;

        coordX--;

        if (coordX < 0 || coordX >= DIM_X)
        {
            cout << "colonna non valida!!!" << endl;
            ok = false;
        }
    } while (!ok);

    do
    {
        ok = true;
        char temp;

        cout << "Inserisci la riga sulla quale vuoi colpire [A-J]: ";
        cin >> temp;
        temp = CHAR_TO_INT(temp);

        //  Visto che char è praticamente un intero possiamo fare sto cosa...
        if (temp < 0 || temp >= DIM_Y)
        {
            cout << "Input Non valido!!!" << endl;
            ok = false;
        }
        coordY = temp;
    } while (!ok);
}



int Gioco(int matGiocatore1[][DIM_Y], int matGiocatore2[][DIM_Y], HANDLE hConsole)
{
    system("cls");

    int coordX, coordY;
    bool ok;

    while (true)
    {
        DisegnaCampo(matGiocatore1, hConsole);
        cout << endl;
        DisegnaBersagli(matGiocatore2, hConsole);

        do
        {
            ok = true;
            cout << "Inserisci le coordinate dove vuoi colpire: " << endl;
            ChiediCoordinate(coordX, coordY);
            if (!NaviColpite(matGiocatore2, coordX, coordY)) {
                ok = false;
            }
        } while (!ok);

        cout << endl;
        system("pause");
        system("cls");

        DisegnaCampo(matGiocatore2, hConsole);
        cout << endl;
        DisegnaBersagli(matGiocatore1, hConsole);

        do
        {
            ok = true;
            cout << "Inserisci le coordinate dove vuoi colpire: " << endl;
            ChiediCoordinate(coordX, coordY);

            if (!NaviColpite(matGiocatore1, coordX, coordY)) {
                ok = false;
            }
        } while (!ok);


        cout << endl;
        system("pause");
        system("cls");
    }
}


bool NaviColpite(int mat[][DIM_Y], int c, int r)
{
    bool ok = false;
    if ((mat[c][r] != ID_ACQUA_COLPITA) && (mat[c][r] != ID_NAVE_COLPITA) && (mat[c][r] != ID_NAVE_AFFONDATA)) //non è stato colpito
    {
        ok = true;
        if (mat[c][r] != ID_ACQUA)
        {
            if (mat[c][r] == ID_NAVE)
            { //da capire se la nave è stata affondata o solo colpita

                //  Calcolo delle coordinate iniziali all'esterno del ciclo per evitare di fare lo stesso calcolo più volte e per motivi di leggibilità.
                int startY = r - ((r <= 0) ? 0 : 1);  //  Se siamo nella prima riga della matrice non possiamo controllare più in alto
                int endY = r + ((r >= (DIM_Y - 1)) ? 0 : 1);   //  Se la nave arriva ad occupare l'ultima riga della matrice non possiamo controllare più in basso
                int startX = c - ((c <= 0) ? 0 : 1);  //  Se siamo nella prima colonna della matrice non possiamo controllare più a sinistra.
                int endX = c + ((c >= (DIM_X - 1)) ? 0 : 1);  //  Se siamo nell'ultima colonna della matrice non possiamo controllare più a destra.

                bool mina = true;
                bool verso;

                //  Settiamo temporaneamente la nave come acqua. Un controllo in meno nel ciclo...
                mat[c][r] = ID_ACQUA;

                int y = startY;
                while (y <= endY)
                {
                    int x = startX;
                    while (x <= endX)
                    {
                        if (mat[x][y] == ID_NAVE || mat[x][y] == ID_NAVE_COLPITA)
                        {
                            if (x < c || x > c)
                            {
                                mina = false;
                                verso = VERSO_ORIZZONTALE;
                                
                                break;
                            }
                            else if (y < r || y > r)
                            {
                                mina = false;
                                verso = VERSO_VERTICALE;

                                break;
                            }
                        }
                        x++;
                    }
                    y++;
                }

                mat[c][r] = ID_NAVE_COLPITA;

                if (mina)  //  Solo la mina
                {
                    cout << "Hai colpito una " << VECT_NOMI_NAVI[0] << "!!!" << endl;
                }
                else {
                    if (verso == VERSO_ORIZZONTALE)
                        //cout << "oriz!!!" << endl;
                        NaveOrizzontale(mat, c, r);
                    else
                        //cout << "vert!!!" << endl;
                        NaveVerticale(mat, c, r);
                }
            }
        }
        else
        {
            cout << "Acqua colpita!" << endl;
            mat[c][r] = ID_ACQUA_COLPITA; //cambio con acqua colpita
            return ok;
        }
    }
    else
        cout << "coordinate già usate!!" << endl;
    return ok;
}


void NaveOrizzontale(int mat[][DIM_Y], int c, int r)
{
    //due step
        //1- mi muovo verso sx per trovare l'acqua
    int temp = c;
    int spostamentiDx = 0;
    int spostamentiSx = 0;

    do
    {
        temp--;
        spostamentiSx++;
        if (mat[temp][r] == ID_NAVE)
        {
            cout << "Nave colpita";
            return;
        }
    } while (temp >= 0 && mat[temp][r] != ID_ACQUA && mat[temp][r] != ID_ACQUA_COLPITA); //continuo finché non trovo acqua
    //nave non trovata = trovato acqua
    temp = c;
    do
    {
        temp++;
        spostamentiDx++;
        if (mat[temp][r] == ID_NAVE)
        {
            cout << "Nave colpita";
            return;
        }
    } while (temp <= (DIM_Y - 1) && mat[temp][r] != ID_ACQUA && mat[temp][r] != ID_ACQUA_COLPITA);
    //vuol dire che non ha trovato altre navi = esce;
    cout << "Nave da " << spostamentiSx + spostamentiDx - 1 << " colpita e affondata!!";

    for (int i = c - spostamentiSx + 1; i <= c + spostamentiDx - 1; i++)
        mat[i][r] = ID_NAVE_AFFONDATA;
}


void NaveVerticale(int mat[][DIM_Y], int c, int r)
{
    //due step
    //1- mi muovo verso sx per trovare l'acqua
    int numCelle = 0;
    int temp = r;
    int spostamentiSu = 0;
    int spostamentiGiu = 0;
    do
    {
        temp--;
        spostamentiSu++;
        if (mat[c][temp] == ID_NAVE)
        {
            cout << "Nave colpita";
            return;
        }
    } while (temp >= 0 && mat[c][temp] != ID_ACQUA && mat[c][temp] != ID_ACQUA_COLPITA); //continuo finché non trovo acqua

    //nave non trovata = trovato acqua
    temp = r;
    do
    {
        temp++;
        spostamentiGiu++;
        if (mat[c][temp] == ID_NAVE)
        {
            cout << "Nave colpita";
            return;
        }
    } while (temp <= (DIM_Y - 1) && mat[c][temp] != ID_ACQUA && mat[c][temp] != ID_ACQUA_COLPITA);
    //vuol dire che non ha trovato altre navi = esce;

    cout << "Nave da " << spostamentiSu + spostamentiGiu - 1 << " colpita e affondata!!";
    for (int i = r - spostamentiSu + 1; i <= r + spostamentiGiu - 1; i++)
        mat[c][i] = ID_NAVE_AFFONDATA;
}